(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{108:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return b})),n.d(t,"default",(function(){return l}));var a=n(2),s=n(7),r=(n(0),n(117)),c={id:"getting-started",title:"Getting Started"},o={id:"getting-started",isDocsHomePage:!0,title:"Getting Started",description:"Reactive store for frontend UI libraries, like React, using Rxjs.",source:"@site/docs/getting-started.md",permalink:"/rx-store/docs/",editUrl:"https://github.com/rx-store/rx-store/edit/master/website/docs/getting-started.md",sidebar:"someSidebar",next:{title:"FAQ",permalink:"/rx-store/docs/faq"}},b=[{value:"Subjects",id:"subjects",children:[{value:"Observables",id:"observables",children:[]}]},{value:"Effects",id:"effects",children:[]},{value:"State vs Streams",id:"state-vs-streams",children:[{value:"Subject",id:"subject",children:[]},{value:"Behavior Subject",id:"behavior-subject",children:[]}]},{value:"Deriving state &quot;up&quot;",id:"deriving-state-up",children:[]},{value:"React Example app",id:"react-example-app",children:[]}],i={rightToc:b};function l(e){var t=e.components,n=Object(s.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},i,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Reactive store for frontend UI libraries, like React, using Rxjs."),Object(r.b)("h1",{id:"motivation"},"Motivation"),Object(r.b)("p",null,'Existing "reactive" stores exist, built with RxJS, but all were all inherently built with "state" instead of "streams", or uses a single global event emitter with a single root state that changes on every update, like ngRx store or redux-observable.'),Object(r.b)("p",null,'In larger redux apps, even with memoization, running every mapStateToProps on every action can be expensive. It is especially problematic if you have lots of things happening over time. For these use cases, it is better to deal with "streams" instead of with "state".'),Object(r.b)("h1",{id:"principles"},"Principles"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Only render/deliver updates for what changed, nothing more."),Object(r.b)("li",{parentName:"ul"},"Only deals with events, not state."),Object(r.b)("li",{parentName:"ul"},'Work with the RxJS API directly, this is not a "wrapper" on top of Rxjs.'),Object(r.b)("li",{parentName:"ul"},'Derive state "up" instead of "down" (read on).')),Object(r.b)("h1",{id:"concepts"},"Concepts"),Object(r.b)("p",null,"Let's walk through the Rx Store concepts using a counter app."),Object(r.b)("h2",{id:"subjects"},"Subjects"),Object(r.b)("p",null,'These "subjects" are closest to what you\'re used to calling your app\'s "state". Instead of state, they are event emitters.'),Object(r.b)("p",null,"Our counter app will use an event bus where we will emit values, in this case a ",Object(r.b)("inlineCode",{parentName:"p"},"count"),"!"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"const appSubjects = {\n  count$: new Subject()\n};\n")),Object(r.b)("p",null,"Subjects should be a single source of truth,\nthey are multi-cast, both read & write. That is, you can subscribe to them, and emit values on them which will be multi-cast to all the subscribers."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"appSubjects.subscribe(x => console.log(`subscriber A ${x}`));\nappSubjects.count$.next(1);\nappSubjects.subscribe(x => console.log(`subscriber B ${x}`));\nappSubjects.count$.next(2);\nappSubjects.count$.next(3);\n\n// subscriber A 1\n// subscriber A 2\n// subscriber B 2\n// subscriber A 3\n// subscriber B 3\n")),Object(r.b)("p",null,"Notice that only ",Object(r.b)("inlineCode",{parentName:"p"},"subscriber A")," received the first value, but after ",Object(r.b)("inlineCode",{parentName:"p"},"subscriber B")," subscribed, both subscribers received all subsequent events. This is all just core RxJS so far, you can run the example code here:"),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://stackblitz.com/edit/rxjs-szr5f9"}),"https://stackblitz.com/edit/rxjs-szr5f9")),Object(r.b)("h3",{id:"observables"},"Observables"),Object(r.b)("p",null,'These "observables" are your app\'s "selectors".'),Object(r.b)("p",null,"They derive state, manipulate time, are lazy &\nuni-cast, and are read only."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"const appObservables = {\n  evenCount$: appSubjects.count$.asObservable().pipe(\n    delay(500),\n    filter((x: number) => x % 2 === 0)\n  ),\n\n  oddCount$: appSubjects.count$.asObservable().pipe(\n    delay(500),\n    filter((x: number) => x % 2 !== 0)\n  )\n};\n")),Object(r.b)("p",null,"Observables, just like subjects, can be subscribed to, however they are uni-cast & lazy, meaning the timer for the ",Object(r.b)("inlineCode",{parentName:"p"},"delay")," will not start a timer until something subscribes, and each subscriber will get its own timer."),Object(r.b)("h2",{id:"effects"},"Effects"),Object(r.b)("p",null,"Effects are where we actually subscribe. We can subscribe directly to our subjects (event emitters), subscribe directly to observables, or create combos using creating operators such as ",Object(r.b)("inlineCode",{parentName:"p"},"merge()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"combineLatest()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"bufferWhen()")," etc."),Object(r.b)("p",null,"Here is an effect that subscribes to the ",Object(r.b)("inlineCode",{parentName:"p"},"count$")," stream of events, delays the events by 1s, and logs them to console."),Object(r.b)("p",null,"Your subscription could emit values back onto the ",Object(r.b)("inlineCode",{parentName:"p"},"count$")," subject if you wanted, which would create an infinite loop."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export const appRootEffect = ({ subjects }) => {\n  const subscription = subjects.count$\n    .pipe(delay(1000))\n    .subscribe(count => console.log({ count }));\n  return () => subscription.unsubscribe();\n};\n")),Object(r.b)("p",null,"Your subscription will more commonly emit onto some other subject, or run some sort of side effect. For example you could subscribe to a subject, and for each event send a network request, and emit the network responses onto some other subject."),Object(r.b)("h2",{id:"state-vs-streams"},"State vs Streams"),Object(r.b)("h3",{id:"subject"},"Subject"),Object(r.b)("p",null,"Let's rename our ",Object(r.b)("inlineCode",{parentName:"p"},"count$")," subject to ",Object(r.b)("inlineCode",{parentName:"p"},"countChange$"),". We're going to switch our thinking from state to streams. No longer will this be a stream of state, it will be a stream of changes!"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"const appSubjects = {\n  countChange$: new Subject()\n};\n")),Object(r.b)("h3",{id:"behavior-subject"},"Behavior Subject"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"const appSubjects = {\n  countChange$: new Subject()\n  count$: new BehaviorSubject(0)\n};\n\n// emits the last [initital] value on subscribe\nappSubjects.count$.subscribe(value => console.log(value));\n")),Object(r.b)("p",null,"Lastly, we add an effect that subscribes to the ",Object(r.b)("inlineCode",{parentName:"p"},"countChange$"),", each time it emits ",Object(r.b)("inlineCode",{parentName:"p"},"1")," or ",Object(r.b)("inlineCode",{parentName:"p"},"-1"),", we'll add that to an accumulator with a ",Object(r.b)("inlineCode",{parentName:"p"},"scan()")," operator, and emit the running total back onto ",Object(r.b)("inlineCode",{parentName:"p"},"count$")," subject:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export const appRootEffect = ({ subjects }) => {\n  const subscription = subjects.streamCounterChange$\n    .asObservable()\n    .pipe(scan((acc, val) => acc + val, 0))\n    .subscribe(count => appSubjects.count$.next(count));\n  return () => subscription.unsubscribe();\n};\n")),Object(r.b)("h2",{id:"deriving-state-up"},'Deriving state "up"'),Object(r.b)("p",null,'In a traditional Redux app, you may be used to paring down the state using selectors, or deriving state "down".'),Object(r.b)("p",null,'When thinking & working reactively, first think about the stream you want, and work backwards from that. The result is you write code that builds the state "up".'),Object(r.b)("p",null,"Example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"const allClick$ = merge(myClick$, yourClick$);\n")),Object(r.b)("p",null,'In this example we\'re working backwards, we wanted a stream of all the clicks, so we defined it. Then we assigned the result of merging two other streams. This merge operator builds "up" the state.'),Object(r.b)("p",null,"Compare this to Redux change detection:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"const mapStateToProps = state => ({\n  user: state.user,\n  page: state.page\n});\n")),Object(r.b)("p",null,'With Redux, you start out with the top level state, and pared it "down" to the subset of state you wanted. This works fine until you have a larger app where running all ',Object(r.b)("inlineCode",{parentName:"p"},"mapStateToProps")," on every state change in the entire app becomes unwieldy. It is also prone to unwanted renders, imagine the ",Object(r.b)("inlineCode",{parentName:"p"},"page")," state looks like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"{\n    name: 'Test',\n    url: '/test',\n}\n")),Object(r.b)("p",null,"Now imagine someone comes along & adds the current time to this object, in a manner where it updates every 100ms (10x a second):"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"{\n    name: 'Test',\n    url: '/test',\n    time: 1592539673319\n}\n")),Object(r.b)("p",null,"With the naive ",Object(r.b)("inlineCode",{parentName:"p"},"mapStateToProps")," function above, your component would re-render with a new ",Object(r.b)("inlineCode",{parentName:"p"},"page")," object 10x a second, even if all the component actually renders is the page's ",Object(r.b)("inlineCode",{parentName:"p"},"name"),"."),Object(r.b)("p",null,"With ",Object(r.b)("inlineCode",{parentName:"p"},"Rx Store"),", we do not have 1 top level state object that is always changing, which we have to pare down & memoize. Instead, we have many low level things updating independantly, and we must subscribe to, merge, or combine them individually, allowing fine grained control of what updates."),Object(r.b)("h2",{id:"react-example-app"},"React Example app"),Object(r.b)("p",null,"Check out the full ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/rx-store/rx-store/tree/master/packages/react-rx-store-example-counter"}),"example counter app")))}l.isMDXComponent=!0}}]);